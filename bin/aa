#!/bin/python3

import os
import logging 
import subprocess as subp
import json
from enum import Enum
logging.basicConfig(filename='main.log', filemode='w',level=logging.DEBUG,format='%(asctime)s -- %(name)s -- %(levelname)s >> %(message)s')
log = logging.getLogger(f'aa')

class Mode(Enum):
    NONE = None
    FORCE = 'FORCE'

class file_management:
    def __init__(self):
        log.debug("init of fm")
        self.set_variables()
        self.current_dir=self.getcwd
    def set_variables(self):
        log.debug('setting variables')
    @property
    def getcwd(self):
        return os.getcwd()

    def mkdir(self,path : str):
        os.mkdir(path)
    
    def cd(self,path : str):
        os.chdir(path)

    @staticmethod
    def readfile(name : str,mode ='w'):
        log.debug(f'readfile method start')
        try:
            with open(name,mode) as op:
               val = op.read()
        except Exception as ex:
            log.error(ex)
            raise ex
        return val
    def is_existing(self,name_of_file : str,localization : str)-> bool:
        return os.path.exists(f'{localization}{name_of_file}')

class Settings:
    def __init__(self):
        log.debug(f'settings init')
        self.settings={}
        self.file_name='settings.json'
        try:
            self.load_dict_settings_from_str()
        except Exception as e:
            log.info(e)
        
        self.default_settings={
            'file_name': 'settings.json'
        }
            
    def load_dict_settings_from_str(self) -> dict:
        try:
            value=file_management.readfile(self.file_name)
        except Exception as ex:
            log.info(ex)
            raise ex
        self.loaded_settings = json.dumps(value)
    
    @staticmethod
    def settings_validation(dict_settings : dict) -> bool:
        return True

    def apply_settings(self):
        for s in self.default_settings:
            self.settings[s] = self.loaded_settings[s] if s in self.loaded_settings else self.default_settings[s]

class subprogram:
    def __init__(self):
        #self.init_variables()
        self.dir_basic = '/bin/'
        self.dir_scripts=f'{self.dir_basic}/skrypty/'
        self.name_of_program = 'aa'

    #def init_variables(self):
        log.debug('init variables subprogram')
        self.template_req='\n'.join(['#!/usr/bin/python3','#import os,sys',f'''os.system('{self.dir_basic}{self.name_of_program} -r '+str(sys.argv[0].split('/')[-1:][0])+' '+' '.join(sys.argv[1:]))'''])
        self.template_example='\n'.join(['#!/usr/bin/python3','#place here python code'])

    def run(self,name : str):
        try:
            log.info(f'try to run {name} script at {self.dir_scripts}')
            self.execute_system_cmd([f'{self.dir_scripts}./{name}'])
        except Exception as ex:
            log.error(ex)
            raise ex
    def create_file(self,name : str,path :str,mode:Mode=Mode.NONE):
        
        fm = file_management()
        if fm.is_existing(name,path):
            if mode == Mode.NONE:
                log.error(f'file existing: {path}, Name of script: {name}')
                raise Exception(f'file existing: {path}, Name of script: {name}')
            if not mode == Mode.FORCE:
                log.debug(f'Stoped creating file due to not force mode')
                raise Exception('Stoped creating file due to not force mode')
        
        with open(f'{path}{name}','w+') as file:
            file.read()
    def create_dir(self):
        #TODO
        pass
    def create_new_req_script(self,name:str,path:str):
        self.create_file(name,self.dir_basic)

        with open(f'{path}{name}', 'w') as file:
            file.write(self.template_req) 


    @staticmethod
    def execute_system_cmd(cmd : str):
        try:
            log.debug(f'trying to execute system command: {cmd}')
            subp.call(cmd)
        except Exception as ex:
            log.error(f'execute system cmd error : {ex}')
            raise ex
    
class basic_fun:
    @staticmethod
    def parse_args():
        import argparse
        ap = argparse.ArgumentParser()
        sprogr = subprogram()
        
        ap.add_argument(
            '-n','--create', type=str, required=False,
            help="create new script", default=''
        )
        ap.add_argument(
            '-r','--run', type=str, required=False, dest = "name_of_program",
            help="run specyfied script", default=''
        )
        ap.add_argument(
            '--install', required=False, action='store_true',
            help="install this program in system directory"
        )

        log.debug('parsing args')
        
        args=ap.parse_args()

        if not args.run is None:
            sprogr.run(args.run)

        elif not args.create is None:
            name=args.create
            
            sprogr.create_new_req_script(name,sprogr.dir_basic)
        


def main():
    log.debug('main')
    basic_fun.parse_args()

    
    #sp = subprogram()
    #sp.run('c')

    
if __name__=="__main__":
    try:
        log.debug('starting main')
        main()
        log.debug('exit main')
    except Exception as e:
        print(e)


