#!/bin/python3

import os
import logging 
import subprocess as subp
import json
from enum import Enum
logging.basicConfig(filename='main.log', filemode='w',level=logging.DEBUG,format='%(asctime)s -- %(name)s -- %(levelname)s >> %(message)s')
log = logging.getLogger(f'aa')
settings = {}

class Mode(Enum):
    NONE = None
    FORCE = 'FORCE'
    ASK = 'ASK'

class file_management:

    def __init__(self):
        log.debug("init of fm")
        self.set_variables()
        self.current_dir=self.getcwd

    def set_variables(self):
        log.debug('setting variables')
    
    @property
    def getcwd(self):
        return os.getcwd()
    
    @staticmethod
    def mkdir(path : str):
        os.mkdir(path)
    
    def cd(self,path : str):
        os.chdir(path)

    @staticmethod
    def readfile(name : str,mode ='r'):
        log.debug(f'readfile method start')
        try:
            with open(name,mode) as op:
               val = op.read()
        except Exception as ex:
            log.error(ex)
            raise ex
        return val

    def writefile(self,value:str):
        #TODO
        pass

    def is_existing(self,localization : str,name_of_file : str)-> bool:
        return os.path.exists(f'{localization}{name_of_file}')
    
    def is_dir(self,path:str,name:str)-> bool:
        return (self.is_existing(path,name) and os.path.isdir(f'{path}/{name}'))

    def is_file(self, path:str,name:str) -> bool:
        return (self.is_existing(path,name) and os.path.isfile(f'{path}/{name}'))

class Settings:

    def __init__(self):
        log.debug(f'settings init')
        global settings
        settings = self.load_settings()
        self.file_name='settings.json'

        self.fm = file_management()

    def load_settings(self):
        global settings
        if not settings == {}:
            return 
        self.default_settings={
            'basic_settings' : '.aa_settings',
            'file_name' : 'settings.json',
            'dir_basic' : '/bin/'
        }
        temp_settings={}

        try:
            temp_settings=self.load_settings_from_file(self.default_settings['basic_settings'])
        except FileNotFoundError as ex:
            settings = self.default_settings
        except Exception as ex:
            log.error(ex)
            raise ex
        else:
            for s in temp_settings:
                self.default_settings[s] = temp_settings[s]
        
        try:
            temp_settings=self.load_settings_from_file(settings['file_name'])
        except FileNotFoundError as ex:
            pass
        except Exception as ex:
            log.error(ex)
            raise ex
        else:
            for s in temp_settings:
                self.default_settings[s] = temp_settings[s]


    def dump_settings_to_file(self,name:str):
        global settings
        if name == '' or name is None:
            log.error("wrong name of file to dump settings")
            raise Exception("wrong name of file to dump settings")
        
        self.fm.writefile( json.dumps(settings))

            
    def load_settings_from_file(self,name:str) -> dict:
        try:
            value=self.fm.readfile(name)
        except Exception as ex:
            log.info(ex)
            raise ex
        return json.loads(value)
    
    @staticmethod
    def settings_validation(dict_settings : dict) -> bool:
        return True

class subprogram:
    def __init__(self):
        global settings
        log.debug('init subprogram')
        self.s = Settings()
        self.dir_basic = settings['dir_basic']
        self.dir_scripts=f'{self.dir_basic}/skrypty/'
        self.name_of_program = 'aa'
        self.template_req='\n'.join(['#!/usr/bin/python3','#import os,sys',f'''os.system('{self.dir_basic}{self.name_of_program} -r '+str(sys.argv[0].split('/')[-1:][0])+' '+' '.join(sys.argv[1:]))'''])
        self.template_example='\n'.join(['#!/usr/bin/python3','#place here python code'])

    def run(self,name : str):
        try:
            log.info(f'try to run {name} script at {self.dir_scripts}')
            self.execute_system_cmd([f'{self.dir_scripts}./{name}'])
        except Exception as ex:
            log.error(ex)
            raise ex

    def create_file(self,name : str,path :str,mode:Mode=Mode.NONE):
        log.debug(f'creating file, name: {name}, path:{path}, mode{mode}')
        fm = file_management()
        if fm.is_existing(path,name):
            if mode == Mode.NONE:
                log.error(f'file existing: {path}, Name of script: {name}')
                raise Exception(f'file existing: {path}, Name of script: {name}')
            if not mode == Mode.FORCE:
                log.debug(f'Stoped creating file due to not force mode')
                raise Exception('Stoped creating file due to not force mode')
        
        with open(f'{path}{name}','w+') as file:
            file.read()

    def create_dir(self,path :str,name:str):
        fm=file_management()
        if fm.is_existing(path,name):
            if not fm.is_dir(path,name):
                log.error(f'at path and name (path: {path}, name: {name})')
                raise Exception(f'at path and name (path: {path}, name: {name})')
            else:
                log.info(f"skipped creating dir due to existing one at {path}/{name}")
        else:
            try:
                os.makedirs(f'{path}/{name}',exist_ok=False)
            except Exception as ex:
                log.error(ex)
                raise ex

    def create_new_req_script(self,name:str,path:str):
        self.create_file(name,self.dir_basic)

        with open(f'{path}{name}', 'w') as file:
            file.write(self.template_req) 


    @staticmethod
    def execute_system_cmd(cmd : str):
        try:
            log.debug(f'trying to execute system command: {cmd}')
            subp.call(cmd)
        except Exception as ex:
            log.error(f'execute system cmd error : {ex}')
            raise ex
    

class main_program:
    def __init__(self):
        self.st=Settings()
    def main(self):
        log.debug(f'started main at main_program')
        self.parse_args()

    
    def parse_args(self):
        import argparse
        ap = argparse.ArgumentParser()
        sprogr = subprogram()
        
        ap.add_argument(
            '-n','--create', type=str, required=False,
            help="create new script", default=''
        )
        ap.add_argument(
            '-r','--run', type=str, required=False, dest = "name_of_program",
            help="run specyfied script", default=''
        )
        ap.add_argument(
            '--install', required=False, action='store_true',
            help="install this program in system directory"
        )

        log.debug('parsing args')
        args=ap.parse_args()

        if not args.run is None:
            sprogr.run(args.run)

        elif not args.create is None:
            name=args.create
            sprogr.create_new_req_script(name,sprogr.dir_basic)
        
    
    def installation(self,mode : Mode = Mode.NONE):
        if mode in [Mode.ASK,Mode.NONE]:
            pass
            
    
if __name__=="__main__":
    try:

        log.debug('starting main')
        main_program().main()
        log.debug('exit main')

    except Exception as e:

        log.error(e)
        print(e)


